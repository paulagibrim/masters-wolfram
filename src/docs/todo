# TODO File - Projeto Gerador de Imagens de ACEs
# Data de Atualiza√ß√£o: 2024-11-18

## Fun√ß√µes necess√°rias
- [x] Aplicar a regra
- [x] Transformar um estado final em imagem
- [x] Gerar imagem para todas as regras
- [x] Aplicar a composi√ß√£o das regras (uma e a outra, depois print)
- [x] Gerar imagem para todas as composi√ß√µes

## Prioridade Alta
- [ ] Arquivo de regras (fun√ß√µes)
- [x] Arquivo de regras (dict)
- [x] Separar as regras por classe
- [x] Gerar estado inicial aleat√≥rio
- [ ] Refatorar o c√≥digo do automaton.py para incluir suporte a vizinhan√ßas maiores.
- [ ] Adicionar valida√ß√£o ao modo ZIP no CellularAutomaton.

## Prioridade M√©dia
- [ ] Criar documenta√ß√£o para a API de gera√ß√£o de imagens.

## Melhorias Futuras
- [ ] Adicionar suporte para visualiza√ß√£o em tempo real (matplotlib).
- [ ] Suporte para aut√¥matos celulares bidimensionais.
- [ ] Sistema de cache para estados intermedi√°rios grandes.
    
# Sobre o cache:

### **1. Salvar o Cache em Outro Arquivo**

Sim, voc√™ pode salvar o cache em um arquivo externo, como um arquivo **JSON**, **pickle**, ou at√© mesmo um **arquivo de texto**, dependendo do formato desejado.

#### **Exemplo Usando `pickle`**
```python
import pickle

# Salvar o cache em um arquivo
with open('cache.pkl', 'wb') as f:
    pickle.dump(self.cache, f)

# Carregar o cache de um arquivo
with open('cache.pkl', 'rb') as f:
    self.cache = pickle.load(f)
```

- **`pickle`** √© √∫til para armazenar objetos Python complexos, como dicion√°rios com arrays.
- O arquivo `cache.pkl` armazenar√° o cache e poder√° ser reutilizado em execu√ß√µes futuras.

---

#### **Exemplo Usando `json`**
Se o cache for compat√≠vel com JSON (ou seja, se as chaves e valores forem tipos simples, como strings ou n√∫meros), voc√™ pode usar:

```python
import json

# Salvar o cache em um arquivo JSON
with open('cache.json', 'w') as f:
    json.dump(self.cache, f)

# Carregar o cache de um arquivo JSON
with open('cache.json', 'r') as f:
    self.cache = json.load(f)
```

- **Limita√ß√£o do JSON**: As chaves do dicion√°rio precisam ser strings. Se voc√™ estiver usando `tuple` como chave, precisar√° convert√™-las para strings antes de salvar.

---

### **2. Dicion√°rio com Duas Chaves**

Embora os dicion√°rios do Python n√£o suportem m√∫ltiplas chaves diretamente, voc√™ pode simular isso de algumas maneiras.

#### **M√©todo 1: Usar uma `tuple` como Chave**
Voc√™ pode combinar as duas chaves em uma `tuple`, que ser√° usada como uma √∫nica chave no dicion√°rio.

```python
# Criando um dicion√°rio com tuplas como chaves
multi_key_dict = {
    (1, 'A'): "Valor 1",
    (2, 'B'): "Valor 2",
}

# Acessando valores
print(multi_key_dict[(1, 'A')])  # Sa√≠da: Valor 1

# Adicionando novos valores
multi_key_dict[(3, 'C')] = "Valor 3"
print(multi_key_dict)
```

---

#### **M√©todo 2: Usar um Dicion√°rio Aninhado**
Voc√™ pode usar um dicion√°rio aninhado, onde a primeira chave aponta para outro dicion√°rio.

```python
# Criando um dicion√°rio aninhado
nested_dict = {
    1: {'A': "Valor 1", 'B': "Valor 2"},
    2: {'A': "Valor 3", 'B': "Valor 4"},
}

# Acessando valores
print(nested_dict[1]['A'])  # Sa√≠da: Valor 1

# Adicionando novos valores
nested_dict[3] = {'C': "Valor 5"}
print(nested_dict)
```

---

### **Qual Abordagem Usar?**

1. **`tuple` como chave**:
   - Use quando as combina√ß√µes de chaves forem est√°ticas ou se voc√™ precisar de acesso r√°pido.
   - Exemplo: Cache onde as duas chaves s√£o o estado anterior e o √≠ndice do passo.

2. **Dicion√°rio aninhado**:
   - Use quando as chaves aninhadas forem organizadas hierarquicamente ou se for mais intuitivo para o seu caso.
   - Exemplo: Agrupar dados por categoria e subcategoria.

---

### **Exemplo Pr√°tico no Contexto do Cache**

Aqui est√° como implementar um cache com duas chaves (estado atual e passo):

#### Usando `tuple` como chave:
```python
self.cache = {}

# Adicionar ao cache
current_state = tuple(self.grid[step])
step_index = step
self.cache[(current_state, step_index)] = next_state

# Acessar do cache
if (current_state, step_index) in self.cache:
    next_state = self.cache[(current_state, step_index)]
```

---

#### Usando dicion√°rio aninhado:
```python
self.cache = {}

# Adicionar ao cache
current_state = tuple(self.grid[step])
if current_state not in self.cache:
    self.cache[current_state] = {}
self.cache[current_state][step] = next_state

# Acessar do cache
if current_state in self.cache and step in self.cache[current_state]:
    next_state = self.cache[current_state][step]
```

---

Se precisar de mais detalhes sobre como salvar, organizar ou acessar o cache, √© s√≥ perguntar! üöÄ





# Legenda:
# - [ ] Pendentes
# - [x] Conclu√≠dos
